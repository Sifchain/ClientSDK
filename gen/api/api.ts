/* tslint:disable */
/* eslint-disable */
/**
 * Sichain API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.3
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AddDelegationResponse
 */
export interface AddDelegationResponse {
    /**
     * 
     * @type {string}
     * @memberof AddDelegationResponse
     */
    delegate?: string;
}
/**
 * 
 * @export
 * @interface ClaimAllRewardsResponse
 */
export interface ClaimAllRewardsResponse {
    /**
     * 
     * @type {string}
     * @memberof ClaimAllRewardsResponse
     */
    rewards?: string;
}
/**
 * 
 * @export
 * @interface ExternalAsset
 */
export interface ExternalAsset {
    /**
     * 
     * @type {string}
     * @memberof ExternalAsset
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalAsset
     */
    balance?: string;
}
/**
 * 
 * @export
 * @interface GetCirculatingSupplyResponse
 */
export interface GetCirculatingSupplyResponse {
    /**
     * 
     * @type {string}
     * @memberof GetCirculatingSupplyResponse
     */
    circulatingSupply?: string;
}
/**
 * 
 * @export
 * @interface GetDelegatorResponse
 */
export interface GetDelegatorResponse {
    /**
     * 
     * @type {string}
     * @memberof GetDelegatorResponse
     */
    validatorAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDelegatorResponse
     */
    validatorName?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDelegatorResponse
     */
    delegationTotal?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDelegatorResponse
     */
    unclaimedRewards?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetDelegatorResponse
     */
    isSlashed?: boolean;
    /**
     * Validator uptime percentage over last 30 days
     * @type {string}
     * @memberof GetDelegatorResponse
     */
    performance?: string;
}
/**
 * 
 * @export
 * @interface GetInactiveValidatorsResponse
 */
export interface GetInactiveValidatorsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetInactiveValidatorsResponse
     */
    inactiveValidator?: string;
}
/**
 * 
 * @export
 * @interface GetLiquidityProviderResponse
 */
export interface GetLiquidityProviderResponse {
    /**
     * 
     * @type {GetLiquidityProvidersResponse}
     * @memberof GetLiquidityProviderResponse
     */
    LiquidityProvider?: GetLiquidityProvidersResponse;
    /**
     * 
     * @type {ExternalAsset}
     * @memberof GetLiquidityProviderResponse
     */
    externalAsset?: ExternalAsset;
    /**
     * 
     * @type {NativeAsset}
     * @memberof GetLiquidityProviderResponse
     */
    nativeAsset?: NativeAsset;
    /**
     * 
     * @type {string}
     * @memberof GetLiquidityProviderResponse
     */
    height?: string;
}
/**
 * 
 * @export
 * @interface GetLiquidityProvidersResponse
 */
export interface GetLiquidityProvidersResponse {
    /**
     * 
     * @type {string}
     * @memberof GetLiquidityProvidersResponse
     */
    units?: string;
    /**
     * 
     * @type {string}
     * @memberof GetLiquidityProvidersResponse
     */
    address?: string;
}
/**
 * 
 * @export
 * @interface GetPeggedAssetsResponse
 */
export interface GetPeggedAssetsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetPeggedAssetsResponse
     */
    tokenName?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPeggedAssetsResponse
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GetPoolResponse
 */
export interface GetPoolResponse {
    /**
     * 
     * @type {GetPoolsResponse}
     * @memberof GetPoolResponse
     */
    Pool?: GetPoolsResponse;
    /**
     * 
     * @type {string}
     * @memberof GetPoolResponse
     */
    clpModuleAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPoolResponse
     */
    height?: string;
}
/**
 * 
 * @export
 * @interface GetPoolsResponse
 */
export interface GetPoolsResponse {
    /**
     * 
     * @type {ExternalAsset}
     * @memberof GetPoolsResponse
     */
    externalAsset?: ExternalAsset;
    /**
     * 
     * @type {NativeAsset}
     * @memberof GetPoolsResponse
     */
    nativeAsset?: NativeAsset;
    /**
     * 
     * @type {string}
     * @memberof GetPoolsResponse
     */
    poolUnits?: string;
}
/**
 * 
 * @export
 * @interface GetTokenValueResponse
 */
export interface GetTokenValueResponse {
    /**
     * 
     * @type {string}
     * @memberof GetTokenValueResponse
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTokenValueResponse
     */
    priceInUSDC?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTokenValueResponse
     */
    priceInRowan?: string;
}
/**
 * 
 * @export
 * @interface GetTotalStakedByDelegatorsResponse
 */
export interface GetTotalStakedByDelegatorsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetTotalStakedByDelegatorsResponse
     */
    amountDelegated?: string;
}
/**
 * 
 * @export
 * @interface GetValidatorResponse
 */
export interface GetValidatorResponse {
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    validatorAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    stakedAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    selfDelegation?: string;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    externalDelegation?: string;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    unclaimedRewards?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetValidatorResponse
     */
    isSlashed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    balance?: string;
    /**
     * Validator uptime percentage over last 30 days
     * @type {string}
     * @memberof GetValidatorResponse
     */
    performance?: string;
}
/**
 * 
 * @export
 * @interface GetValidatorsResponse
 */
export interface GetValidatorsResponse extends Array<object> {
}
/**
 * 
 * @export
 * @interface NativeAsset
 */
export interface NativeAsset {
    /**
     * 
     * @type {string}
     * @memberof NativeAsset
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof NativeAsset
     */
    balance?: string;
}
/**
 * 
 * @export
 * @interface NetworkResponse
 */
export interface NetworkResponse {
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    totalRowanStaked?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    totalUSDStaked?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    blockReward?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    averageBlockTime?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    averageFee?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    totalUsers?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    networkBondingTime?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    validatorMinimumBondAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    delegatorMinimumBondAmount?: string;
}
/**
 * 
 * @export
 * @interface PegAssetsResponse
 */
export interface PegAssetsResponse {
    /**
     * 
     * @type {string}
     * @memberof PegAssetsResponse
     */
    peg?: string;
}
/**
 * 
 * @export
 * @interface PoolShareResponse
 */
export interface PoolShareResponse {
    /**
     * 
     * @type {string}
     * @memberof PoolShareResponse
     */
    poolShare?: string;
}
/**
 * 
 * @export
 * @interface ReDelegateResponse
 */
export interface ReDelegateResponse {
    /**
     * 
     * @type {string}
     * @memberof ReDelegateResponse
     */
    redelegate?: string;
}
/**
 * 
 * @export
 * @interface SetCommissionRateResponse
 */
export interface SetCommissionRateResponse {
    /**
     * 
     * @type {string}
     * @memberof SetCommissionRateResponse
     */
    amount?: string;
}
/**
 * 
 * @export
 * @interface SetWithdrawAddressResponse
 */
export interface SetWithdrawAddressResponse {
    /**
     * 
     * @type {string}
     * @memberof SetWithdrawAddressResponse
     */
    withdraw?: string;
}
/**
 * 
 * @export
 * @interface SwapTokenResponse
 */
export interface SwapTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof SwapTokenResponse
     */
    token?: string;
}
/**
 * 
 * @export
 * @interface UnDelegateResponse
 */
export interface UnDelegateResponse {
    /**
     * 
     * @type {string}
     * @memberof UnDelegateResponse
     */
    undelegate?: string;
}
/**
 * 
 * @export
 * @interface UnJailResponse
 */
export interface UnJailResponse {
    /**
     * 
     * @type {string}
     * @memberof UnJailResponse
     */
    unjail?: string;
}
/**
 * 
 * @export
 * @interface UnPegAssetsResponse
 */
export interface UnPegAssetsResponse {
    /**
     * 
     * @type {string}
     * @memberof UnPegAssetsResponse
     */
    peg?: string;
}
/**
 * 
 * @export
 * @interface WithdrawRewardsResponse
 */
export interface WithdrawRewardsResponse {
    /**
     * 
     * @type {string}
     * @memberof WithdrawRewardsResponse
     */
    amount?: string;
}

/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCirculatingSupply: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCirculatingSupply', 'symbol', symbol)
            const localVarPath = `/asset/{symbol}/circulatingSupply`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenValue: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTokenValue', 'symbol', symbol)
            const localVarPath = `/asset/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} fromAddress 
         * @param {string} toAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapToken: async (fromAddress: string, toAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('swapToken', 'fromAddress', fromAddress)
            // verify required parameter 'toAddress' is not null or undefined
            assertParamExists('swapToken', 'toAddress', toAddress)
            const localVarPath = `/asset/swapToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }

            if (toAddress !== undefined) {
                localVarQueryParameter['toAddress'] = toAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCirculatingSupply(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCirculatingSupplyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCirculatingSupply(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenValue(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTokenValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenValue(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} fromAddress 
         * @param {string} toAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async swapToken(fromAddress: string, toAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SwapTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.swapToken(fromAddress, toAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCirculatingSupply(symbol: string, options?: any): AxiosPromise<GetCirculatingSupplyResponse> {
            return localVarFp.getCirculatingSupply(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenValue(symbol: string, options?: any): AxiosPromise<GetTokenValueResponse> {
            return localVarFp.getTokenValue(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} fromAddress 
         * @param {string} toAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        swapToken(fromAddress: string, toAddress: string, options?: any): AxiosPromise<SwapTokenResponse> {
            return localVarFp.swapToken(fromAddress, toAddress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getCirculatingSupply(symbol: string, options?: any) {
        return AssetsApiFp(this.configuration).getCirculatingSupply(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getTokenValue(symbol: string, options?: any) {
        return AssetsApiFp(this.configuration).getTokenValue(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} fromAddress 
     * @param {string} toAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public swapToken(fromAddress: string, toAddress: string, options?: any) {
        return AssetsApiFp(this.configuration).swapToken(fromAddress, toAddress, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkApi - axios parameter creator
 * @export
 */
export const NetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkApi - functional programming interface
 * @export
 */
export const NetworkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkApi - factory interface
 * @export
 */
export const NetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkInfo(options?: any): AxiosPromise<NetworkResponse> {
            return localVarFp.getNetworkInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkApi - object-oriented interface
 * @export
 * @class NetworkApi
 * @extends {BaseAPI}
 */
export class NetworkApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public getNetworkInfo(options?: any) {
        return NetworkApiFp(this.configuration).getNetworkInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PeggyApi - axios parameter creator
 * @export
 */
export const PeggyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeggedAssets: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getPeggedAssets', 'key', key)
            const localVarPath = `/peggy/peggedAssets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {string} externalAssetSymbol 
         * @param {number} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pegAssets: async (key: string, externalAssetSymbol: string, externalAmount: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('pegAssets', 'key', key)
            // verify required parameter 'externalAssetSymbol' is not null or undefined
            assertParamExists('pegAssets', 'externalAssetSymbol', externalAssetSymbol)
            // verify required parameter 'externalAmount' is not null or undefined
            assertParamExists('pegAssets', 'externalAmount', externalAmount)
            const localVarPath = `/peggy/pegAssets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (externalAssetSymbol !== undefined) {
                localVarQueryParameter['externalAssetSymbol'] = externalAssetSymbol;
            }

            if (externalAmount !== undefined) {
                localVarQueryParameter['externalAmount'] = externalAmount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} key 
         * @param {string} externalAssetSymbol 
         * @param {number} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unPegAssets: async (key: string, externalAssetSymbol: string, externalAmount: number, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('unPegAssets', 'key', key)
            // verify required parameter 'externalAssetSymbol' is not null or undefined
            assertParamExists('unPegAssets', 'externalAssetSymbol', externalAssetSymbol)
            // verify required parameter 'externalAmount' is not null or undefined
            assertParamExists('unPegAssets', 'externalAmount', externalAmount)
            const localVarPath = `/peggy/unPegAssets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (externalAssetSymbol !== undefined) {
                localVarQueryParameter['externalAssetSymbol'] = externalAssetSymbol;
            }

            if (externalAmount !== undefined) {
                localVarQueryParameter['externalAmount'] = externalAmount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeggyApi - functional programming interface
 * @export
 */
export const PeggyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeggyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeggedAssets(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPeggedAssetsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeggedAssets(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} key 
         * @param {string} externalAssetSymbol 
         * @param {number} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pegAssets(key: string, externalAssetSymbol: string, externalAmount: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PegAssetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pegAssets(key, externalAssetSymbol, externalAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} key 
         * @param {string} externalAssetSymbol 
         * @param {number} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unPegAssets(key: string, externalAssetSymbol: string, externalAmount: number, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnPegAssetsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unPegAssets(key, externalAssetSymbol, externalAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PeggyApi - factory interface
 * @export
 */
export const PeggyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeggyApiFp(configuration)
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeggedAssets(key: string, options?: any): AxiosPromise<Array<GetPeggedAssetsResponse>> {
            return localVarFp.getPeggedAssets(key, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {string} externalAssetSymbol 
         * @param {number} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pegAssets(key: string, externalAssetSymbol: string, externalAmount: number, options?: any): AxiosPromise<PegAssetsResponse> {
            return localVarFp.pegAssets(key, externalAssetSymbol, externalAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} key 
         * @param {string} externalAssetSymbol 
         * @param {number} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unPegAssets(key: string, externalAssetSymbol: string, externalAmount: number, options?: any): AxiosPromise<UnPegAssetsResponse> {
            return localVarFp.unPegAssets(key, externalAssetSymbol, externalAmount, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeggyApi - object-oriented interface
 * @export
 * @class PeggyApi
 * @extends {BaseAPI}
 */
export class PeggyApi extends BaseAPI {
    /**
     * 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeggyApi
     */
    public getPeggedAssets(key: string, options?: any) {
        return PeggyApiFp(this.configuration).getPeggedAssets(key, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} key 
     * @param {string} externalAssetSymbol 
     * @param {number} externalAmount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeggyApi
     */
    public pegAssets(key: string, externalAssetSymbol: string, externalAmount: number, options?: any) {
        return PeggyApiFp(this.configuration).pegAssets(key, externalAssetSymbol, externalAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} key 
     * @param {string} externalAssetSymbol 
     * @param {number} externalAmount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeggyApi
     */
    public unPegAssets(key: string, externalAssetSymbol: string, externalAmount: number, options?: any) {
        return PeggyApiFp(this.configuration).unPegAssets(key, externalAssetSymbol, externalAmount, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoolsApi - axios parameter creator
 * @export
 */
export const PoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add liquidity to a specified pool.
         * @param {string} from 
         * @param {string} symbol 
         * @param {string} nativeAmount 
         * @param {string} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLiquidity: async (from: string, symbol: string, nativeAmount: string, externalAmount: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('addLiquidity', 'from', from)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('addLiquidity', 'symbol', symbol)
            // verify required parameter 'nativeAmount' is not null or undefined
            assertParamExists('addLiquidity', 'nativeAmount', nativeAmount)
            // verify required parameter 'externalAmount' is not null or undefined
            assertParamExists('addLiquidity', 'externalAmount', externalAmount)
            const localVarPath = `/pool/addLiquidity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (nativeAmount !== undefined) {
                localVarQueryParameter['nativeAmount'] = nativeAmount;
            }

            if (externalAmount !== undefined) {
                localVarQueryParameter['externalAmount'] = externalAmount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary The pool to create.
         * @param {string} key 
         * @param {string} externalAssetSymbol 
         * @param {string} rowanAmount 
         * @param {string} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPool: async (key: string, externalAssetSymbol: string, rowanAmount: string, externalAmount: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('createPool', 'key', key)
            // verify required parameter 'externalAssetSymbol' is not null or undefined
            assertParamExists('createPool', 'externalAssetSymbol', externalAssetSymbol)
            // verify required parameter 'rowanAmount' is not null or undefined
            assertParamExists('createPool', 'rowanAmount', rowanAmount)
            // verify required parameter 'externalAmount' is not null or undefined
            assertParamExists('createPool', 'externalAmount', externalAmount)
            const localVarPath = `/pool/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            if (externalAssetSymbol !== undefined) {
                localVarQueryParameter['externalAssetSymbol'] = externalAssetSymbol;
            }

            if (rowanAmount !== undefined) {
                localVarQueryParameter['rowanAmount'] = rowanAmount;
            }

            if (externalAmount !== undefined) {
                localVarQueryParameter['externalAmount'] = externalAmount;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityProvider: async (symbol: string, lpAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getLiquidityProvider', 'symbol', symbol)
            // verify required parameter 'lpAddress' is not null or undefined
            assertParamExists('getLiquidityProvider', 'lpAddress', lpAddress)
            const localVarPath = `/pool/{symbol}/liquidityProvider/{lpAddress}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)))
                .replace(`{${"lpAddress"}}`, encodeURIComponent(String(lpAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityProviders: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getLiquidityProviders', 'symbol', symbol)
            const localVarPath = `/pool/{symbol}/liquidityProvider`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPool', 'symbol', symbol)
            const localVarPath = `/pool/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolShare: async (symbol: string, lpAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPoolShare', 'symbol', symbol)
            // verify required parameter 'lpAddress' is not null or undefined
            assertParamExists('getPoolShare', 'lpAddress', lpAddress)
            const localVarPath = `/pool/{symbol}/liquidityProvider/{lpAddress}/share`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)))
                .replace(`{${"lpAddress"}}`, encodeURIComponent(String(lpAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove liquidity from a specified pool.
         * @param {string} from 
         * @param {string} symbol 
         * @param {string} wBasis 
         * @param {string} asymmetry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeliquidity: async (from: string, symbol: string, wBasis: string, asymmetry: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'from' is not null or undefined
            assertParamExists('removeliquidity', 'from', from)
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('removeliquidity', 'symbol', symbol)
            // verify required parameter 'wBasis' is not null or undefined
            assertParamExists('removeliquidity', 'wBasis', wBasis)
            // verify required parameter 'asymmetry' is not null or undefined
            assertParamExists('removeliquidity', 'asymmetry', asymmetry)
            const localVarPath = `/pool/removeliquidity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (from !== undefined) {
                localVarQueryParameter['from'] = from;
            }

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (wBasis !== undefined) {
                localVarQueryParameter['wBasis'] = wBasis;
            }

            if (asymmetry !== undefined) {
                localVarQueryParameter['asymmetry'] = asymmetry;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoolsApi - functional programming interface
 * @export
 */
export const PoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Add liquidity to a specified pool.
         * @param {string} from 
         * @param {string} symbol 
         * @param {string} nativeAmount 
         * @param {string} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addLiquidity(from: string, symbol: string, nativeAmount: string, externalAmount: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addLiquidity(from, symbol, nativeAmount, externalAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary The pool to create.
         * @param {string} key 
         * @param {string} externalAssetSymbol 
         * @param {string} rowanAmount 
         * @param {string} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPool(key: string, externalAssetSymbol: string, rowanAmount: string, externalAmount: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPool(key, externalAssetSymbol, rowanAmount, externalAmount, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiquidityProvider(symbol: string, lpAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLiquidityProviderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityProvider(symbol, lpAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiquidityProviders(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetLiquidityProvidersResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityProviders(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPool(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPoolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPool(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoolShare(symbol: string, lpAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolShareResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoolShare(symbol, lpAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPools(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPoolsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPools(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove liquidity from a specified pool.
         * @param {string} from 
         * @param {string} symbol 
         * @param {string} wBasis 
         * @param {string} asymmetry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeliquidity(from: string, symbol: string, wBasis: string, asymmetry: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeliquidity(from, symbol, wBasis, asymmetry, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoolsApi - factory interface
 * @export
 */
export const PoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoolsApiFp(configuration)
    return {
        /**
         * 
         * @summary Add liquidity to a specified pool.
         * @param {string} from 
         * @param {string} symbol 
         * @param {string} nativeAmount 
         * @param {string} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLiquidity(from: string, symbol: string, nativeAmount: string, externalAmount: string, options?: any): AxiosPromise<string> {
            return localVarFp.addLiquidity(from, symbol, nativeAmount, externalAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary The pool to create.
         * @param {string} key 
         * @param {string} externalAssetSymbol 
         * @param {string} rowanAmount 
         * @param {string} externalAmount 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPool(key: string, externalAssetSymbol: string, rowanAmount: string, externalAmount: string, options?: any): AxiosPromise<string> {
            return localVarFp.createPool(key, externalAssetSymbol, rowanAmount, externalAmount, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityProvider(symbol: string, lpAddress: string, options?: any): AxiosPromise<GetLiquidityProviderResponse> {
            return localVarFp.getLiquidityProvider(symbol, lpAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityProviders(symbol: string, options?: any): AxiosPromise<Array<GetLiquidityProvidersResponse>> {
            return localVarFp.getLiquidityProviders(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(symbol: string, options?: any): AxiosPromise<GetPoolResponse> {
            return localVarFp.getPool(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolShare(symbol: string, lpAddress: string, options?: any): AxiosPromise<PoolShareResponse> {
            return localVarFp.getPoolShare(symbol, lpAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(options?: any): AxiosPromise<Array<GetPoolsResponse>> {
            return localVarFp.getPools(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove liquidity from a specified pool.
         * @param {string} from 
         * @param {string} symbol 
         * @param {string} wBasis 
         * @param {string} asymmetry 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeliquidity(from: string, symbol: string, wBasis: string, asymmetry: string, options?: any): AxiosPromise<string> {
            return localVarFp.removeliquidity(from, symbol, wBasis, asymmetry, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoolsApi - object-oriented interface
 * @export
 * @class PoolsApi
 * @extends {BaseAPI}
 */
export class PoolsApi extends BaseAPI {
    /**
     * 
     * @summary Add liquidity to a specified pool.
     * @param {string} from 
     * @param {string} symbol 
     * @param {string} nativeAmount 
     * @param {string} externalAmount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public addLiquidity(from: string, symbol: string, nativeAmount: string, externalAmount: string, options?: any) {
        return PoolsApiFp(this.configuration).addLiquidity(from, symbol, nativeAmount, externalAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary The pool to create.
     * @param {string} key 
     * @param {string} externalAssetSymbol 
     * @param {string} rowanAmount 
     * @param {string} externalAmount 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public createPool(key: string, externalAssetSymbol: string, rowanAmount: string, externalAmount: string, options?: any) {
        return PoolsApiFp(this.configuration).createPool(key, externalAssetSymbol, rowanAmount, externalAmount, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {string} lpAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getLiquidityProvider(symbol: string, lpAddress: string, options?: any) {
        return PoolsApiFp(this.configuration).getLiquidityProvider(symbol, lpAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getLiquidityProviders(symbol: string, options?: any) {
        return PoolsApiFp(this.configuration).getLiquidityProviders(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getPool(symbol: string, options?: any) {
        return PoolsApiFp(this.configuration).getPool(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {string} lpAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getPoolShare(symbol: string, lpAddress: string, options?: any) {
        return PoolsApiFp(this.configuration).getPoolShare(symbol, lpAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getPools(options?: any) {
        return PoolsApiFp(this.configuration).getPools(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove liquidity from a specified pool.
     * @param {string} from 
     * @param {string} symbol 
     * @param {string} wBasis 
     * @param {string} asymmetry 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public removeliquidity(from: string, symbol: string, wBasis: string, asymmetry: string, options?: any) {
        return PoolsApiFp(this.configuration).removeliquidity(from, symbol, wBasis, asymmetry, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValidatorsApi - axios parameter creator
 * @export
 */
export const ValidatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDelegation: async (validatorAddress: string, amount: string, fromAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('addDelegation', 'validatorAddress', validatorAddress)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('addDelegation', 'amount', amount)
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('addDelegation', 'fromAddress', fromAddress)
            const localVarPath = `/validator/delegate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (validatorAddress !== undefined) {
                localVarQueryParameter['validatorAddress'] = validatorAddress;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimAllRewards: async (address: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('claimAllRewards', 'address', address)
            const localVarPath = `/validator/claimAllRewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} delegatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegator: async (delegatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            assertParamExists('getDelegator', 'delegatorAddress', delegatorAddress)
            const localVarPath = `/validator/delegator/{delegatorAddress}`
                .replace(`{${"delegatorAddress"}}`, encodeURIComponent(String(delegatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegators: async (validatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('getDelegators', 'validatorAddress', validatorAddress)
            const localVarPath = `/validator/{validatorAddress}/delegator`
                .replace(`{${"validatorAddress"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveValidators: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/validator/inactiveValidators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalStakedByDelegators: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/validator/delegator/totalStaked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator: async (validatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('getValidator', 'validatorAddress', validatorAddress)
            const localVarPath = `/validator/{validatorAddress}`
                .replace(`{${"validatorAddress"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidators: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/validator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reDelegate: async (validatorAddress: string, amount: string, fromAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('reDelegate', 'validatorAddress', validatorAddress)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('reDelegate', 'amount', amount)
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('reDelegate', 'fromAddress', fromAddress)
            const localVarPath = `/validator/reDelegate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (validatorAddress !== undefined) {
                localVarQueryParameter['validatorAddress'] = validatorAddress;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} rate 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCommissionRate: async (rate: string, validatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'rate' is not null or undefined
            assertParamExists('setCommissionRate', 'rate', rate)
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('setCommissionRate', 'validatorAddress', validatorAddress)
            const localVarPath = `/validator/setCommissionRate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (rate !== undefined) {
                localVarQueryParameter['rate'] = rate;
            }

            if (validatorAddress !== undefined) {
                localVarQueryParameter['validatorAddress'] = validatorAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} toAddress 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWithdrawAddress: async (toAddress: string, fromAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'toAddress' is not null or undefined
            assertParamExists('setWithdrawAddress', 'toAddress', toAddress)
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('setWithdrawAddress', 'fromAddress', fromAddress)
            const localVarPath = `/validator/setWithdrawAddress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (toAddress !== undefined) {
                localVarQueryParameter['toAddress'] = toAddress;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDelegate: async (validatorAddress: string, amount: string, fromAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('unDelegate', 'validatorAddress', validatorAddress)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('unDelegate', 'amount', amount)
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('unDelegate', 'fromAddress', fromAddress)
            const localVarPath = `/validator/unDelegate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (validatorAddress !== undefined) {
                localVarQueryParameter['validatorAddress'] = validatorAddress;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} moniker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unJail: async (moniker: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'moniker' is not null or undefined
            assertParamExists('unJail', 'moniker', moniker)
            const localVarPath = `/validator/unJail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (moniker !== undefined) {
                localVarQueryParameter['moniker'] = moniker;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRewards: async (validatorAddress: string, amount: string, fromAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('withdrawRewards', 'validatorAddress', validatorAddress)
            // verify required parameter 'amount' is not null or undefined
            assertParamExists('withdrawRewards', 'amount', amount)
            // verify required parameter 'fromAddress' is not null or undefined
            assertParamExists('withdrawRewards', 'fromAddress', fromAddress)
            const localVarPath = `/validator/withdrawRewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (validatorAddress !== undefined) {
                localVarQueryParameter['validatorAddress'] = validatorAddress;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (fromAddress !== undefined) {
                localVarQueryParameter['fromAddress'] = fromAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValidatorsApi - functional programming interface
 * @export
 */
export const ValidatorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValidatorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addDelegation(validatorAddress: string, amount: string, fromAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddDelegationResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addDelegation(validatorAddress, amount, fromAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async claimAllRewards(address: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ClaimAllRewardsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.claimAllRewards(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} delegatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDelegator(delegatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDelegatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDelegator(delegatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDelegators(validatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDelegators(validatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInactiveValidators(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetInactiveValidatorsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInactiveValidators(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalStakedByDelegators(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTotalStakedByDelegatorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalStakedByDelegators(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidator(validatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetValidatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidator(validatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidators(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidators(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reDelegate(validatorAddress: string, amount: string, fromAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ReDelegateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reDelegate(validatorAddress, amount, fromAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} rate 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setCommissionRate(rate: string, validatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetCommissionRateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setCommissionRate(rate, validatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} toAddress 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setWithdrawAddress(toAddress: string, fromAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SetWithdrawAddressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setWithdrawAddress(toAddress, fromAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unDelegate(validatorAddress: string, amount: string, fromAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnDelegateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unDelegate(validatorAddress, amount, fromAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} moniker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async unJail(moniker: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UnJailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.unJail(moniker, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawRewards(validatorAddress: string, amount: string, fromAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawRewardsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawRewards(validatorAddress, amount, fromAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValidatorsApi - factory interface
 * @export
 */
export const ValidatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValidatorsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDelegation(validatorAddress: string, amount: string, fromAddress: string, options?: any): AxiosPromise<AddDelegationResponse> {
            return localVarFp.addDelegation(validatorAddress, amount, fromAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} address 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        claimAllRewards(address: string, options?: any): AxiosPromise<ClaimAllRewardsResponse> {
            return localVarFp.claimAllRewards(address, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} delegatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegator(delegatorAddress: string, options?: any): AxiosPromise<GetDelegatorResponse> {
            return localVarFp.getDelegator(delegatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegators(validatorAddress: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getDelegators(validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveValidators(options?: any): AxiosPromise<Array<GetInactiveValidatorsResponse>> {
            return localVarFp.getInactiveValidators(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalStakedByDelegators(options?: any): AxiosPromise<GetTotalStakedByDelegatorsResponse> {
            return localVarFp.getTotalStakedByDelegators(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator(validatorAddress: string, options?: any): AxiosPromise<GetValidatorResponse> {
            return localVarFp.getValidator(validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidators(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getValidators(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reDelegate(validatorAddress: string, amount: string, fromAddress: string, options?: any): AxiosPromise<ReDelegateResponse> {
            return localVarFp.reDelegate(validatorAddress, amount, fromAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} rate 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setCommissionRate(rate: string, validatorAddress: string, options?: any): AxiosPromise<SetCommissionRateResponse> {
            return localVarFp.setCommissionRate(rate, validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} toAddress 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setWithdrawAddress(toAddress: string, fromAddress: string, options?: any): AxiosPromise<SetWithdrawAddressResponse> {
            return localVarFp.setWithdrawAddress(toAddress, fromAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unDelegate(validatorAddress: string, amount: string, fromAddress: string, options?: any): AxiosPromise<UnDelegateResponse> {
            return localVarFp.unDelegate(validatorAddress, amount, fromAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} moniker 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        unJail(moniker: string, options?: any): AxiosPromise<UnJailResponse> {
            return localVarFp.unJail(moniker, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {string} amount 
         * @param {string} fromAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawRewards(validatorAddress: string, amount: string, fromAddress: string, options?: any): AxiosPromise<WithdrawRewardsResponse> {
            return localVarFp.withdrawRewards(validatorAddress, amount, fromAddress, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValidatorsApi - object-oriented interface
 * @export
 * @class ValidatorsApi
 * @extends {BaseAPI}
 */
export class ValidatorsApi extends BaseAPI {
    /**
     * 
     * @param {string} validatorAddress 
     * @param {string} amount 
     * @param {string} fromAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public addDelegation(validatorAddress: string, amount: string, fromAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).addDelegation(validatorAddress, amount, fromAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} address 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public claimAllRewards(address: string, options?: any) {
        return ValidatorsApiFp(this.configuration).claimAllRewards(address, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} delegatorAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getDelegator(delegatorAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).getDelegator(delegatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} validatorAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getDelegators(validatorAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).getDelegators(validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getInactiveValidators(options?: any) {
        return ValidatorsApiFp(this.configuration).getInactiveValidators(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getTotalStakedByDelegators(options?: any) {
        return ValidatorsApiFp(this.configuration).getTotalStakedByDelegators(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} validatorAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getValidator(validatorAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).getValidator(validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getValidators(options?: any) {
        return ValidatorsApiFp(this.configuration).getValidators(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} validatorAddress 
     * @param {string} amount 
     * @param {string} fromAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public reDelegate(validatorAddress: string, amount: string, fromAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).reDelegate(validatorAddress, amount, fromAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} rate 
     * @param {string} validatorAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public setCommissionRate(rate: string, validatorAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).setCommissionRate(rate, validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} toAddress 
     * @param {string} fromAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public setWithdrawAddress(toAddress: string, fromAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).setWithdrawAddress(toAddress, fromAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} validatorAddress 
     * @param {string} amount 
     * @param {string} fromAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public unDelegate(validatorAddress: string, amount: string, fromAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).unDelegate(validatorAddress, amount, fromAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} moniker 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public unJail(moniker: string, options?: any) {
        return ValidatorsApiFp(this.configuration).unJail(moniker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} validatorAddress 
     * @param {string} amount 
     * @param {string} fromAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public withdrawRewards(validatorAddress: string, amount: string, fromAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).withdrawRewards(validatorAddress, amount, fromAddress, options).then((request) => request(this.axios, this.basePath));
    }
}


