/* tslint:disable */
/* eslint-disable */
/**
 * Sichain API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.0.4
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ExternalAsset
 */
export interface ExternalAsset {
    /**
     * 
     * @type {string}
     * @memberof ExternalAsset
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof ExternalAsset
     */
    balance?: string;
}
/**
 * 
 * @export
 * @interface GetCirculatingSupplyResponse
 */
export interface GetCirculatingSupplyResponse {
    /**
     * 
     * @type {string}
     * @memberof GetCirculatingSupplyResponse
     */
    circulatingSupply?: string;
}
/**
 * 
 * @export
 * @interface GetDelegatorResponse
 */
export interface GetDelegatorResponse {
    /**
     * 
     * @type {string}
     * @memberof GetDelegatorResponse
     */
    validatorAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDelegatorResponse
     */
    validatorName?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDelegatorResponse
     */
    delegationTotal?: string;
    /**
     * 
     * @type {string}
     * @memberof GetDelegatorResponse
     */
    unclaimedRewards?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetDelegatorResponse
     */
    isSlashed?: boolean;
    /**
     * Validator uptime percentage over last 30 days
     * @type {string}
     * @memberof GetDelegatorResponse
     */
    performance?: string;
}
/**
 * 
 * @export
 * @interface GetInactiveValidatorsResponse
 */
export interface GetInactiveValidatorsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetInactiveValidatorsResponse
     */
    inactiveValidator?: string;
}
/**
 * 
 * @export
 * @interface GetLiquidityProviderResponse
 */
export interface GetLiquidityProviderResponse {
    /**
     * 
     * @type {GetLiquidityProvidersResponse}
     * @memberof GetLiquidityProviderResponse
     */
    LiquidityProvider?: GetLiquidityProvidersResponse;
    /**
     * 
     * @type {ExternalAsset}
     * @memberof GetLiquidityProviderResponse
     */
    externalAsset?: ExternalAsset;
    /**
     * 
     * @type {NativeAsset}
     * @memberof GetLiquidityProviderResponse
     */
    nativeAsset?: NativeAsset;
    /**
     * 
     * @type {string}
     * @memberof GetLiquidityProviderResponse
     */
    height?: string;
}
/**
 * 
 * @export
 * @interface GetLiquidityProvidersResponse
 */
export interface GetLiquidityProvidersResponse {
    /**
     * 
     * @type {string}
     * @memberof GetLiquidityProvidersResponse
     */
    units?: string;
    /**
     * 
     * @type {string}
     * @memberof GetLiquidityProvidersResponse
     */
    address?: string;
}
/**
 * 
 * @export
 * @interface GetPeggedAssetsResponse
 */
export interface GetPeggedAssetsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetPeggedAssetsResponse
     */
    tokenName?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPeggedAssetsResponse
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GetPoolResponse
 */
export interface GetPoolResponse {
    /**
     * 
     * @type {GetPoolsResponse}
     * @memberof GetPoolResponse
     */
    Pool?: GetPoolsResponse;
    /**
     * 
     * @type {string}
     * @memberof GetPoolResponse
     */
    clpModuleAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPoolResponse
     */
    height?: string;
}
/**
 * 
 * @export
 * @interface GetPoolsResponse
 */
export interface GetPoolsResponse {
    /**
     * 
     * @type {ExternalAsset}
     * @memberof GetPoolsResponse
     */
    externalAsset?: ExternalAsset;
    /**
     * 
     * @type {NativeAsset}
     * @memberof GetPoolsResponse
     */
    nativeAsset?: NativeAsset;
    /**
     * 
     * @type {string}
     * @memberof GetPoolsResponse
     */
    poolUnits?: string;
}
/**
 * 
 * @export
 * @interface GetTokenValueResponse
 */
export interface GetTokenValueResponse {
    /**
     * 
     * @type {string}
     * @memberof GetTokenValueResponse
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTokenValueResponse
     */
    priceInUSDC?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTokenValueResponse
     */
    priceInRowan?: string;
}
/**
 * 
 * @export
 * @interface GetTotalStakedByDelegatorsResponse
 */
export interface GetTotalStakedByDelegatorsResponse {
    /**
     * 
     * @type {string}
     * @memberof GetTotalStakedByDelegatorsResponse
     */
    amountDelegated?: string;
}
/**
 * 
 * @export
 * @interface GetValidatorResponse
 */
export interface GetValidatorResponse {
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    validatorAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    stakedAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    selfDelegation?: string;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    externalDelegation?: string;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    unclaimedRewards?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GetValidatorResponse
     */
    isSlashed?: boolean;
    /**
     * 
     * @type {string}
     * @memberof GetValidatorResponse
     */
    balance?: string;
    /**
     * Validator uptime percentage over last 30 days
     * @type {string}
     * @memberof GetValidatorResponse
     */
    performance?: string;
}
/**
 * 
 * @export
 * @interface GetValidatorsResponse
 */
export interface GetValidatorsResponse extends Array<object> {
}
/**
 * 
 * @export
 * @interface NativeAsset
 */
export interface NativeAsset {
    /**
     * 
     * @type {string}
     * @memberof NativeAsset
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof NativeAsset
     */
    balance?: string;
}
/**
 * 
 * @export
 * @interface NetworkResponse
 */
export interface NetworkResponse {
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    totalRowanStaked?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    totalUSDStaked?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    blockReward?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    averageBlockTime?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    averageFee?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    totalUsers?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    networkBondingTime?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    validatorMinimumBondAmount?: string;
    /**
     * 
     * @type {string}
     * @memberof NetworkResponse
     */
    delegatorMinimumBondAmount?: string;
}
/**
 * 
 * @export
 * @interface PoolShareResponse
 */
export interface PoolShareResponse {
    /**
     * 
     * @type {string}
     * @memberof PoolShareResponse
     */
    poolShare?: string;
}

/**
 * AssetsApi - axios parameter creator
 * @export
 */
export const AssetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenValue: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getTokenValue', 'symbol', symbol)
            const localVarPath = `/asset/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalSupply: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/asset/totalSupply`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetsApi - functional programming interface
 * @export
 */
export const AssetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AssetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTokenValue(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTokenValueResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTokenValue(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalSupply(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCirculatingSupplyResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalSupply(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AssetsApi - factory interface
 * @export
 */
export const AssetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AssetsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTokenValue(symbol: string, options?: any): AxiosPromise<GetTokenValueResponse> {
            return localVarFp.getTokenValue(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalSupply(options?: any): AxiosPromise<GetCirculatingSupplyResponse> {
            return localVarFp.getTotalSupply(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AssetsApi - object-oriented interface
 * @export
 * @class AssetsApi
 * @extends {BaseAPI}
 */
export class AssetsApi extends BaseAPI {
    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getTokenValue(symbol: string, options?: any) {
        return AssetsApiFp(this.configuration).getTokenValue(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetsApi
     */
    public getTotalSupply(options?: any) {
        return AssetsApiFp(this.configuration).getTotalSupply(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NetworkApi - axios parameter creator
 * @export
 */
export const NetworkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyPrice: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/dailyPrice`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalPrice: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getHistoricalPrice', 'symbol', symbol)
            const localVarPath = `/historicalPrice/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkInfo: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkApi - functional programming interface
 * @export
 */
export const NetworkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDailyPrice(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDailyPrice(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoricalPrice(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoricalPrice(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkInfo(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NetworkApi - factory interface
 * @export
 */
export const NetworkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDailyPrice(options?: any): AxiosPromise<NetworkResponse> {
            return localVarFp.getDailyPrice(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoricalPrice(symbol: string, options?: any): AxiosPromise<NetworkResponse> {
            return localVarFp.getHistoricalPrice(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkInfo(options?: any): AxiosPromise<NetworkResponse> {
            return localVarFp.getNetworkInfo(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkApi - object-oriented interface
 * @export
 * @class NetworkApi
 * @extends {BaseAPI}
 */
export class NetworkApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public getDailyPrice(options?: any) {
        return NetworkApiFp(this.configuration).getDailyPrice(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public getHistoricalPrice(symbol: string, options?: any) {
        return NetworkApiFp(this.configuration).getHistoricalPrice(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkApi
     */
    public getNetworkInfo(options?: any) {
        return NetworkApiFp(this.configuration).getNetworkInfo(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PeggyApi - axios parameter creator
 * @export
 */
export const PeggyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeggedAssets: async (key: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'key' is not null or undefined
            assertParamExists('getPeggedAssets', 'key', key)
            const localVarPath = `/peggy/peggedAssets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PeggyApi - functional programming interface
 * @export
 */
export const PeggyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PeggyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPeggedAssets(key: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPeggedAssetsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPeggedAssets(key, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PeggyApi - factory interface
 * @export
 */
export const PeggyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PeggyApiFp(configuration)
    return {
        /**
         * 
         * @param {string} key 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPeggedAssets(key: string, options?: any): AxiosPromise<Array<GetPeggedAssetsResponse>> {
            return localVarFp.getPeggedAssets(key, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PeggyApi - object-oriented interface
 * @export
 * @class PeggyApi
 * @extends {BaseAPI}
 */
export class PeggyApi extends BaseAPI {
    /**
     * 
     * @param {string} key 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PeggyApi
     */
    public getPeggedAssets(key: string, options?: any) {
        return PeggyApiFp(this.configuration).getPeggedAssets(key, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PoolsApi - axios parameter creator
 * @export
 */
export const PoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityProvider: async (symbol: string, lpAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getLiquidityProvider', 'symbol', symbol)
            // verify required parameter 'lpAddress' is not null or undefined
            assertParamExists('getLiquidityProvider', 'lpAddress', lpAddress)
            const localVarPath = `/pool/{symbol}/liquidityProvider/{lpAddress}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)))
                .replace(`{${"lpAddress"}}`, encodeURIComponent(String(lpAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityProviders: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getLiquidityProviders', 'symbol', symbol)
            const localVarPath = `/pool/{symbol}/liquidityProvider`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool: async (symbol: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPool', 'symbol', symbol)
            const localVarPath = `/pool/{symbol}`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolShare: async (symbol: string, lpAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getPoolShare', 'symbol', symbol)
            // verify required parameter 'lpAddress' is not null or undefined
            assertParamExists('getPoolShare', 'lpAddress', lpAddress)
            const localVarPath = `/pool/{symbol}/liquidityProvider/{lpAddress}/share`
                .replace(`{${"symbol"}}`, encodeURIComponent(String(symbol)))
                .replace(`{${"lpAddress"}}`, encodeURIComponent(String(lpAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/pool`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoolsApi - functional programming interface
 * @export
 */
export const PoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiquidityProvider(symbol: string, lpAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetLiquidityProviderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityProvider(symbol, lpAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLiquidityProviders(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetLiquidityProvidersResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLiquidityProviders(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPool(symbol: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPoolResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPool(symbol, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPoolShare(symbol: string, lpAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoolShareResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPoolShare(symbol, lpAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPools(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetPoolsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPools(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PoolsApi - factory interface
 * @export
 */
export const PoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoolsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityProvider(symbol: string, lpAddress: string, options?: any): AxiosPromise<GetLiquidityProviderResponse> {
            return localVarFp.getLiquidityProvider(symbol, lpAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLiquidityProviders(symbol: string, options?: any): AxiosPromise<Array<GetLiquidityProvidersResponse>> {
            return localVarFp.getLiquidityProviders(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPool(symbol: string, options?: any): AxiosPromise<GetPoolResponse> {
            return localVarFp.getPool(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} symbol 
         * @param {string} lpAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPoolShare(symbol: string, lpAddress: string, options?: any): AxiosPromise<PoolShareResponse> {
            return localVarFp.getPoolShare(symbol, lpAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPools(options?: any): AxiosPromise<Array<GetPoolsResponse>> {
            return localVarFp.getPools(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoolsApi - object-oriented interface
 * @export
 * @class PoolsApi
 * @extends {BaseAPI}
 */
export class PoolsApi extends BaseAPI {
    /**
     * 
     * @param {string} symbol 
     * @param {string} lpAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getLiquidityProvider(symbol: string, lpAddress: string, options?: any) {
        return PoolsApiFp(this.configuration).getLiquidityProvider(symbol, lpAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getLiquidityProviders(symbol: string, options?: any) {
        return PoolsApiFp(this.configuration).getLiquidityProviders(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getPool(symbol: string, options?: any) {
        return PoolsApiFp(this.configuration).getPool(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} symbol 
     * @param {string} lpAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getPoolShare(symbol: string, lpAddress: string, options?: any) {
        return PoolsApiFp(this.configuration).getPoolShare(symbol, lpAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoolsApi
     */
    public getPools(options?: any) {
        return PoolsApiFp(this.configuration).getPools(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ValidatorsApi - axios parameter creator
 * @export
 */
export const ValidatorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} delegatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegator: async (delegatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'delegatorAddress' is not null or undefined
            assertParamExists('getDelegator', 'delegatorAddress', delegatorAddress)
            const localVarPath = `/validator/delegator/{delegatorAddress}`
                .replace(`{${"delegatorAddress"}}`, encodeURIComponent(String(delegatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegators: async (validatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('getDelegators', 'validatorAddress', validatorAddress)
            const localVarPath = `/validator/{validatorAddress}/delegator`
                .replace(`{${"validatorAddress"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveValidators: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/validator/inactiveValidators`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalStakedByDelegators: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/validator/delegator/totalStaked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator: async (validatorAddress: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'validatorAddress' is not null or undefined
            assertParamExists('getValidator', 'validatorAddress', validatorAddress)
            const localVarPath = `/validator/{validatorAddress}`
                .replace(`{${"validatorAddress"}}`, encodeURIComponent(String(validatorAddress)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidators: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/validator`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter, options.query);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ValidatorsApi - functional programming interface
 * @export
 */
export const ValidatorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ValidatorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} delegatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDelegator(delegatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetDelegatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDelegator(delegatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDelegators(validatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDelegators(validatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getInactiveValidators(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetInactiveValidatorsResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getInactiveValidators(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTotalStakedByDelegators(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTotalStakedByDelegatorsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTotalStakedByDelegators(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidator(validatorAddress: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetValidatorResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidator(validatorAddress, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getValidators(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getValidators(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ValidatorsApi - factory interface
 * @export
 */
export const ValidatorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ValidatorsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} delegatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegator(delegatorAddress: string, options?: any): AxiosPromise<GetDelegatorResponse> {
            return localVarFp.getDelegator(delegatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDelegators(validatorAddress: string, options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getDelegators(validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInactiveValidators(options?: any): AxiosPromise<Array<GetInactiveValidatorsResponse>> {
            return localVarFp.getInactiveValidators(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTotalStakedByDelegators(options?: any): AxiosPromise<GetTotalStakedByDelegatorsResponse> {
            return localVarFp.getTotalStakedByDelegators(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} validatorAddress 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidator(validatorAddress: string, options?: any): AxiosPromise<GetValidatorResponse> {
            return localVarFp.getValidator(validatorAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getValidators(options?: any): AxiosPromise<Array<object>> {
            return localVarFp.getValidators(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ValidatorsApi - object-oriented interface
 * @export
 * @class ValidatorsApi
 * @extends {BaseAPI}
 */
export class ValidatorsApi extends BaseAPI {
    /**
     * 
     * @param {string} delegatorAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getDelegator(delegatorAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).getDelegator(delegatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} validatorAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getDelegators(validatorAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).getDelegators(validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getInactiveValidators(options?: any) {
        return ValidatorsApiFp(this.configuration).getInactiveValidators(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getTotalStakedByDelegators(options?: any) {
        return ValidatorsApiFp(this.configuration).getTotalStakedByDelegators(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} validatorAddress 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getValidator(validatorAddress: string, options?: any) {
        return ValidatorsApiFp(this.configuration).getValidator(validatorAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ValidatorsApi
     */
    public getValidators(options?: any) {
        return ValidatorsApiFp(this.configuration).getValidators(options).then((request) => request(this.axios, this.basePath));
    }
}


